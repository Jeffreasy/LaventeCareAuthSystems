# Database Guardrails

## üè∞ The Database Fortress
Per **Anti-Gravity Law 3**, the database is treated as a fortress. Access is strictly controlled, and raw SQL construction is forbidden in the application layer.

### Technology Stack
- **Engine**: PostgreSQL 15+
- **Driver**: `pgx/v5` (High performance, binary protocol)
- **Interface**: `sqlc` (Type-safe SQL compiler)

---

## üìê Schema Overview

The schema is designed for multi-tenancy and strict isolation.

### Core Tables
1.  **Tenants (`tenants`)**
    - The root of isolation. Every user and resource belongs to a context (though users can belong to multiple tenants via memberships).
    - **Key Fields**: `slug` (public ID), `public_key`, `secret_key`, `allowed_origins`, `app_url`.

2.  **Users (`users`)**
    - Global identity. Authenticates via Email/Password.
    - **Security**:
        - Passwords: Bcrypt hash.
        - **MFA**: `mfa_secret` (encrypted/stored) and `mfa_enabled` flag.

3.  **Memberships (`memberships`)**
    - Join table linking `Users` <-> `Tenants`.
    - Defines `role` (e.g., `admin`, `viewer`).

4.  **Refresh Tokens (`refresh_tokens`)**
    - Long-lived revocable tokens for rotating access.
    - **Security**: Stored as hashes (`token_hash`), not raw tokens.
    - **Metadata**: Stores `ip_address` and `user_agent` for Session Management.
    - **Rotation**: Stores `family_id` and `parent_token_id` to detect reuse and chain revocation.

5.  **Verification Tokens (`verification_tokens`)**
    - Short-lived, single-use tokens for Password Reset and Email Verification.
    - **Security**: **SHA256** hashed. Deterministic lookup allows strictly scoped lifecycle management.

6. **MFA Backup Codes (`mfa_backup_codes`)**
    - **Hashed** recovery codes. Linked to User.
    - Fields: `code_hash`, `used` (bool), `used_at`.

7. **Invitations (`invitations`)**
    - Pre-registration access tokens.
    - Fields: `email`, `role`, `tenant_id`, `token_hash`, `expires_at`.

---

## üõ°Ô∏è SQLC & Type Safety

We do not write `SELECT * FROM ...` in Go strings. We write SQL in `.sql` files, and `sqlc` generates the Go code.

**Workflow:**
1.  Edit `internal/storage/queries/*.sql`.
2.  Run `sqlc generate`.
3.  Call the generated methods in `internal/storage/db/`.

**Why?**
- **Zero SQL Injection**: Parameters are strictly typed.
- **Fail Fast**: Syntax errors are caught at compile time, not runtime.
- **Performance**: Optimized prepared statements.

### Example Pattern
*Bad (Forbidden):*
```go
db.Query("SELECT * FROM users WHERE email = '" + email + "'") // ‚ùå VULNERABLE
```

*Good (Enforced):*
```go
// Generated by sqlc
user, err := queries.GetUserByEmail(ctx, email) // ‚úÖ SAFE
```

---

## üîí Row Level Security & Isolation

Every query targeting tenant-specific data **MUST** include a `tenant_id` WHERE clause.

- **Correct**: `WHERE user_id = $1 AND tenant_id = $2`
- **Incorrect**: `WHERE user_id = $1` (This creates an IDOR vulnerability)

*Note: In the future, we may enable Postgres Native RLS for defense-in-depth.*
