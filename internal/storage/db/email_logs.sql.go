// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: email_logs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEmailLog = `-- name: CreateEmailLog :one
INSERT INTO email_logs (
    tenant_id,
    recipient_hash,
    template_type,
    status,
    provider_msg_id,
    provider_error,
    sent_at
) VALUES (
    $1, $2, $3, $4, $5, $6,
    CASE WHEN $4 = 'sent' THEN NOW() ELSE NULL END
) RETURNING id, tenant_id, recipient_hash, template_type, status, provider_msg_id, provider_error, created_at, sent_at, retry_count, last_retry_at
`

type CreateEmailLogParams struct {
	TenantID      pgtype.UUID
	RecipientHash string
	TemplateType  string
	Status        string
	ProviderMsgID pgtype.Text
	ProviderError pgtype.Text
}

// Creates an audit log entry for email delivery
func (q *Queries) CreateEmailLog(ctx context.Context, arg CreateEmailLogParams) (EmailLog, error) {
	row := q.db.QueryRow(ctx, createEmailLog,
		arg.TenantID,
		arg.RecipientHash,
		arg.TemplateType,
		arg.Status,
		arg.ProviderMsgID,
		arg.ProviderError,
	)
	var i EmailLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RecipientHash,
		&i.TemplateType,
		&i.Status,
		&i.ProviderMsgID,
		&i.ProviderError,
		&i.CreatedAt,
		&i.SentAt,
		&i.RetryCount,
		&i.LastRetryAt,
	)
	return i, err
}

const getEmailLogByRecipientHash = `-- name: GetEmailLogByRecipientHash :many
SELECT id, tenant_id, recipient_hash, template_type, status, provider_msg_id, provider_error, created_at, sent_at, retry_count, last_retry_at FROM email_logs
WHERE recipient_hash = $1
ORDER BY created_at DESC
`

// Find all emails sent to a specific recipient (for GDPR requests)
func (q *Queries) GetEmailLogByRecipientHash(ctx context.Context, recipientHash string) ([]EmailLog, error) {
	rows, err := q.db.Query(ctx, getEmailLogByRecipientHash, recipientHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailLog
	for rows.Next() {
		var i EmailLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.RecipientHash,
			&i.TemplateType,
			&i.Status,
			&i.ProviderMsgID,
			&i.ProviderError,
			&i.CreatedAt,
			&i.SentAt,
			&i.RetryCount,
			&i.LastRetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailLogStats = `-- name: GetEmailLogStats :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'sent') as sent_count,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_count,
    COUNT(*) FILTER (WHERE status = 'bounced') as bounced_count,
    COUNT(*) FILTER (WHERE status = 'spam_complaint') as spam_count
FROM email_logs
WHERE tenant_id = $1
  AND created_at > $2
`

type GetEmailLogStatsParams struct {
	TenantID  pgtype.UUID
	CreatedAt pgtype.Timestamptz
}

type GetEmailLogStatsRow struct {
	SentCount    int64
	FailedCount  int64
	BouncedCount int64
	SpamCount    int64
}

// Dashboard query: Get email delivery statistics
func (q *Queries) GetEmailLogStats(ctx context.Context, arg GetEmailLogStatsParams) (GetEmailLogStatsRow, error) {
	row := q.db.QueryRow(ctx, getEmailLogStats, arg.TenantID, arg.CreatedAt)
	var i GetEmailLogStatsRow
	err := row.Scan(
		&i.SentCount,
		&i.FailedCount,
		&i.BouncedCount,
		&i.SpamCount,
	)
	return i, err
}

const getEmailLogsByTenant = `-- name: GetEmailLogsByTenant :many
SELECT id, tenant_id, recipient_hash, template_type, status, provider_msg_id, provider_error, created_at, sent_at, retry_count, last_retry_at FROM email_logs
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetEmailLogsByTenantParams struct {
	TenantID pgtype.UUID
	Limit    int32
	Offset   int32
}

// Dashboard query: Get recent email logs for a tenant
func (q *Queries) GetEmailLogsByTenant(ctx context.Context, arg GetEmailLogsByTenantParams) ([]EmailLog, error) {
	rows, err := q.db.Query(ctx, getEmailLogsByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailLog
	for rows.Next() {
		var i EmailLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.RecipientHash,
			&i.TemplateType,
			&i.Status,
			&i.ProviderMsgID,
			&i.ProviderError,
			&i.CreatedAt,
			&i.SentAt,
			&i.RetryCount,
			&i.LastRetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmailLogStatus = `-- name: UpdateEmailLogStatus :exec
UPDATE email_logs
SET status = $2,
    provider_error = $3
WHERE id = $1
`

type UpdateEmailLogStatusParams struct {
	ID            pgtype.UUID
	Status        string
	ProviderError pgtype.Text
}

// Updates the status of an email log (e.g., bounced, spam_complaint)
func (q *Queries) UpdateEmailLogStatus(ctx context.Context, arg UpdateEmailLogStatusParams) error {
	_, err := q.db.Exec(ctx, updateEmailLogStatus, arg.ID, arg.Status, arg.ProviderError)
	return err
}
