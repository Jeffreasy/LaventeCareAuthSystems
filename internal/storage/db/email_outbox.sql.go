// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: email_outbox.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const enqueueEmail = `-- name: EnqueueEmail :one
INSERT INTO email_outbox (
    tenant_id,
    payload,
    status,
    next_retry_at
) VALUES (
    $1, $2, 'pending', NOW()
) RETURNING id, tenant_id, payload, status, retry_count, max_retries, next_retry_at, last_error, created_at, processing_started_at, processed_at, email_log_id
`

type EnqueueEmailParams struct {
	TenantID pgtype.UUID
	Payload  json.RawMessage
}

// Enqueues an email for async processing by the worker
func (q *Queries) EnqueueEmail(ctx context.Context, arg EnqueueEmailParams) (EmailOutbox, error) {
	row := q.db.QueryRow(ctx, enqueueEmail, arg.TenantID, arg.Payload)
	var i EmailOutbox
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.NextRetryAt,
		&i.LastError,
		&i.CreatedAt,
		&i.ProcessingStartedAt,
		&i.ProcessedAt,
		&i.EmailLogID,
	)
	return i, err
}

const getOutboxStats = `-- name: GetOutboxStats :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE status = 'processing') as processing_count,
    COUNT(*) FILTER (WHERE status = 'sent') as sent_count,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_count
FROM email_outbox
WHERE tenant_id = $1
  AND created_at > NOW() - INTERVAL '24 hours'
`

type GetOutboxStatsRow struct {
	PendingCount    int64
	ProcessingCount int64
	SentCount       int64
	FailedCount     int64
}

// Dashboard query: Get email queue statistics for a tenant
func (q *Queries) GetOutboxStats(ctx context.Context, tenantID pgtype.UUID) (GetOutboxStatsRow, error) {
	row := q.db.QueryRow(ctx, getOutboxStats, tenantID)
	var i GetOutboxStatsRow
	err := row.Scan(
		&i.PendingCount,
		&i.ProcessingCount,
		&i.SentCount,
		&i.FailedCount,
	)
	return i, err
}

const getPendingEmails = `-- name: GetPendingEmails :many
SELECT id, tenant_id, payload, status, retry_count, max_retries, next_retry_at, last_error, created_at, processing_started_at, processed_at, email_log_id FROM email_outbox
WHERE status = 'pending'
  AND next_retry_at <= NOW()
ORDER BY created_at ASC
LIMIT $1
FOR UPDATE SKIP LOCKED
`

// Worker query: Fetch pending emails ready for processing
// Uses FOR UPDATE SKIP LOCKED to prevent race conditions between workers
func (q *Queries) GetPendingEmails(ctx context.Context, limit int32) ([]EmailOutbox, error) {
	rows, err := q.db.Query(ctx, getPendingEmails, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailOutbox
	for rows.Next() {
		var i EmailOutbox
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.MaxRetries,
			&i.NextRetryAt,
			&i.LastError,
			&i.CreatedAt,
			&i.ProcessingStartedAt,
			&i.ProcessedAt,
			&i.EmailLogID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTenantMailConfig = `-- name: GetTenantMailConfig :one
SELECT mail_config, mail_config_key_version
FROM tenants
WHERE id = $1 AND mail_config IS NOT NULL
`

type GetTenantMailConfigRow struct {
	MailConfig           []byte
	MailConfigKeyVersion pgtype.Int4
}

// Fetches tenant-specific SMTP configuration
// SECURITY: Only use this in the background worker (has access to encrypted credentials)
func (q *Queries) GetTenantMailConfig(ctx context.Context, id pgtype.UUID) (GetTenantMailConfigRow, error) {
	row := q.db.QueryRow(ctx, getTenantMailConfig, id)
	var i GetTenantMailConfigRow
	err := row.Scan(&i.MailConfig, &i.MailConfigKeyVersion)
	return i, err
}

const markEmailFailed = `-- name: MarkEmailFailed :exec
UPDATE email_outbox
SET status = CASE
        WHEN retry_count >= max_retries THEN 'failed'
        ELSE 'pending'
    END,
    retry_count = retry_count + 1,
    last_error = $2,
    next_retry_at = CASE
        WHEN retry_count >= max_retries THEN NULL
        ELSE NOW() + (POWER(2, retry_count) * INTERVAL '5 minutes')
    END
WHERE id = $1
`

type MarkEmailFailedParams struct {
	ID        pgtype.UUID
	LastError pgtype.Text
}

// Marks an email as failed and schedules retry
func (q *Queries) MarkEmailFailed(ctx context.Context, arg MarkEmailFailedParams) error {
	_, err := q.db.Exec(ctx, markEmailFailed, arg.ID, arg.LastError)
	return err
}

const markEmailProcessing = `-- name: MarkEmailProcessing :exec
UPDATE email_outbox
SET status = 'processing',
    processing_started_at = NOW()
WHERE id = $1
`

// Marks an email as being processed (prevents duplicate sends)
func (q *Queries) MarkEmailProcessing(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markEmailProcessing, id)
	return err
}

const markEmailSent = `-- name: MarkEmailSent :exec
UPDATE email_outbox
SET status = 'sent',
    processed_at = NOW(),
    email_log_id = $2
WHERE id = $1
`

type MarkEmailSentParams struct {
	ID         pgtype.UUID
	EmailLogID pgtype.UUID
}

// Marks an email as successfully sent
func (q *Queries) MarkEmailSent(ctx context.Context, arg MarkEmailSentParams) error {
	_, err := q.db.Exec(ctx, markEmailSent, arg.ID, arg.EmailLogID)
	return err
}

const updateTenantMailConfig = `-- name: UpdateTenantMailConfig :exec
UPDATE tenants
SET mail_config = $2,
    mail_config_key_version = $3,
    updated_at = NOW()
WHERE id = $1
`

type UpdateTenantMailConfigParams struct {
	ID                   pgtype.UUID
	MailConfig           []byte
	MailConfigKeyVersion pgtype.Int4
}

// Updates tenant SMTP configuration (admin panel)
func (q *Queries) UpdateTenantMailConfig(ctx context.Context, arg UpdateTenantMailConfigParams) error {
	_, err := q.db.Exec(ctx, updateTenantMailConfig, arg.ID, arg.MailConfig, arg.MailConfigKeyVersion)
	return err
}
