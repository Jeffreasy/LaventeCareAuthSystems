// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: memberships.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMembership = `-- name: CreateMembership :one
INSERT INTO memberships (
    user_id, tenant_id, role
) VALUES (
    $1, $2, $3
) RETURNING id, user_id, tenant_id, role, created_at
`

type CreateMembershipParams struct {
	UserID   pgtype.UUID
	TenantID pgtype.UUID
	Role     string
}

func (q *Queries) CreateMembership(ctx context.Context, arg CreateMembershipParams) (Membership, error) {
	row := q.db.QueryRow(ctx, createMembership, arg.UserID, arg.TenantID, arg.Role)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const getMembership = `-- name: GetMembership :one
SELECT role FROM memberships 
WHERE user_id = $1 AND tenant_id = $2
`

type GetMembershipParams struct {
	UserID   pgtype.UUID
	TenantID pgtype.UUID
}

func (q *Queries) GetMembership(ctx context.Context, arg GetMembershipParams) (string, error) {
	row := q.db.QueryRow(ctx, getMembership, arg.UserID, arg.TenantID)
	var role string
	err := row.Scan(&role)
	return role, err
}

const getMembershipsByUser = `-- name: GetMembershipsByUser :many
SELECT id, user_id, tenant_id, role, created_at FROM memberships
WHERE user_id = $1
`

func (q *Queries) GetMembershipsByUser(ctx context.Context, userID pgtype.UUID) ([]Membership, error) {
	rows, err := q.db.Query(ctx, getMembershipsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TenantID,
			&i.Role,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenantMembers = `-- name: ListTenantMembers :many
SELECT 
    u.id, 
    u.email, 
    u.full_name, 
    m.role, 
    m.created_at as joined_at
FROM memberships m
JOIN users u ON m.user_id = u.id
WHERE m.tenant_id = $1
ORDER BY m.created_at DESC
`

type ListTenantMembersRow struct {
	ID       pgtype.UUID
	Email    string
	FullName pgtype.Text
	Role     string
	JoinedAt pgtype.Timestamptz
}

func (q *Queries) ListTenantMembers(ctx context.Context, tenantID pgtype.UUID) ([]ListTenantMembersRow, error) {
	rows, err := q.db.Query(ctx, listTenantMembers, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTenantMembersRow
	for rows.Next() {
		var i ListTenantMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FullName,
			&i.Role,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMember = `-- name: RemoveMember :exec
DELETE FROM memberships
WHERE user_id = $1 AND tenant_id = $2
`

type RemoveMemberParams struct {
	UserID   pgtype.UUID
	TenantID pgtype.UUID
}

func (q *Queries) RemoveMember(ctx context.Context, arg RemoveMemberParams) error {
	_, err := q.db.Exec(ctx, removeMember, arg.UserID, arg.TenantID)
	return err
}

const updateMemberRole = `-- name: UpdateMemberRole :exec
UPDATE memberships
SET role = $1, updated_at = NOW()
WHERE user_id = $2 AND tenant_id = $3
`

type UpdateMemberRoleParams struct {
	Role     string
	UserID   pgtype.UUID
	TenantID pgtype.UUID
}

func (q *Queries) UpdateMemberRole(ctx context.Context, arg UpdateMemberRoleParams) error {
	_, err := q.db.Exec(ctx, updateMemberRole, arg.Role, arg.UserID, arg.TenantID)
	return err
}
