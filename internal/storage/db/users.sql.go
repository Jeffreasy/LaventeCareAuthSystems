// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email, password_hash, full_name, default_tenant_id, mfa_secret, mfa_enabled
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, email, password_hash, full_name, is_email_verified, default_tenant_id, created_at, updated_at, mfa_secret, mfa_enabled, failed_login_attempts, locked_until
`

type CreateUserParams struct {
	Email           string
	PasswordHash    pgtype.Text
	FullName        pgtype.Text
	DefaultTenantID pgtype.UUID
	MfaSecret       pgtype.Text
	MfaEnabled      bool
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.FullName,
		arg.DefaultTenantID,
		arg.MfaSecret,
		arg.MfaEnabled,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsEmailVerified,
		&i.DefaultTenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MfaSecret,
		&i.MfaEnabled,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
	)
	return i, err
}

const createUserFromInvitation = `-- name: CreateUserFromInvitation :one
WITH new_user AS (
    INSERT INTO users (email, password_hash, is_email_verified)
    VALUES ($1, $2, TRUE) -- Verified because they got the invite email
    RETURNING id, email, created_at
),
new_membership AS (
    INSERT INTO memberships (user_id, tenant_id, role)
    SELECT id, $3, $4
    FROM new_user
    RETURNING user_id
),
deleted_invite AS (
    DELETE FROM invitations 
    WHERE token_hash = $5
)
SELECT id, email, created_at FROM new_user
`

type CreateUserFromInvitationParams struct {
	Email        string
	PasswordHash pgtype.Text
	TenantID     pgtype.UUID
	Role         string
	TokenHash    string
}

type CreateUserFromInvitationRow struct {
	ID        pgtype.UUID
	Email     string
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) CreateUserFromInvitation(ctx context.Context, arg CreateUserFromInvitationParams) (CreateUserFromInvitationRow, error) {
	row := q.db.QueryRow(ctx, createUserFromInvitation,
		arg.Email,
		arg.PasswordHash,
		arg.TenantID,
		arg.Role,
		arg.TokenHash,
	)
	var i CreateUserFromInvitationRow
	err := row.Scan(&i.ID, &i.Email, &i.CreatedAt)
	return i, err
}

const createUserWithMembership = `-- name: CreateUserWithMembership :one
WITH new_user AS (
    INSERT INTO users (email, password_hash, full_name, default_tenant_id, mfa_secret, mfa_enabled)
    VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
    )
    RETURNING id, email, password_hash, full_name, is_email_verified, default_tenant_id, created_at, updated_at, mfa_secret, mfa_enabled, failed_login_attempts, locked_until
),
new_membership AS (
    INSERT INTO memberships (user_id, tenant_id, role)
    SELECT new_user.id, $7::uuid, $8
    FROM new_user
    WHERE $7 IS NOT NULL
    RETURNING user_id
)
SELECT id, email, password_hash, full_name, is_email_verified, default_tenant_id, created_at, updated_at, mfa_secret, mfa_enabled, failed_login_attempts, locked_until FROM new_user
`

type CreateUserWithMembershipParams struct {
	Email                 string
	PasswordHash          pgtype.Text
	FullName              pgtype.Text
	DefaultTenantID       pgtype.UUID
	MfaSecret             pgtype.Text
	MfaEnabled            bool
	TenantIDForMembership pgtype.UUID
	Role                  string
}

type CreateUserWithMembershipRow struct {
	ID                  pgtype.UUID
	Email               string
	PasswordHash        pgtype.Text
	FullName            pgtype.Text
	IsEmailVerified     bool
	DefaultTenantID     pgtype.UUID
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	MfaSecret           pgtype.Text
	MfaEnabled          bool
	FailedLoginAttempts int32
	LockedUntil         pgtype.Timestamptz
}

// Atomically creates a user and their default tenant membership
// Prevents orphan users if membership creation fails (resolves TODO service.go:175)
// Note: Membership is only created if tenant_id_for_membership is NOT NULL
func (q *Queries) CreateUserWithMembership(ctx context.Context, arg CreateUserWithMembershipParams) (CreateUserWithMembershipRow, error) {
	row := q.db.QueryRow(ctx, createUserWithMembership,
		arg.Email,
		arg.PasswordHash,
		arg.FullName,
		arg.DefaultTenantID,
		arg.MfaSecret,
		arg.MfaEnabled,
		arg.TenantIDForMembership,
		arg.Role,
	)
	var i CreateUserWithMembershipRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsEmailVerified,
		&i.DefaultTenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MfaSecret,
		&i.MfaEnabled,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, full_name, is_email_verified, default_tenant_id, created_at, updated_at, mfa_secret, mfa_enabled, failed_login_attempts, locked_until FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsEmailVerified,
		&i.DefaultTenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MfaSecret,
		&i.MfaEnabled,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, full_name, is_email_verified, default_tenant_id, created_at, updated_at, mfa_secret, mfa_enabled, failed_login_attempts, locked_until FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsEmailVerified,
		&i.DefaultTenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MfaSecret,
		&i.MfaEnabled,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
	)
	return i, err
}

const getUserContext = `-- name: GetUserContext :one
SELECT 
    u.id, 
    u.email, 
    u.full_name,
    m.role,
    t.id as tenant_id,
    t.slug as tenant_slug
FROM users u
JOIN memberships m ON u.id = m.user_id
JOIN tenants t ON m.tenant_id = t.id
WHERE u.id = $1 AND t.id = $2
`

type GetUserContextParams struct {
	ID   pgtype.UUID
	ID_2 pgtype.UUID
}

type GetUserContextRow struct {
	ID         pgtype.UUID
	Email      string
	FullName   pgtype.Text
	Role       string
	TenantID   pgtype.UUID
	TenantSlug string
}

func (q *Queries) GetUserContext(ctx context.Context, arg GetUserContextParams) (GetUserContextRow, error) {
	row := q.db.QueryRow(ctx, getUserContext, arg.ID, arg.ID_2)
	var i GetUserContextRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.Role,
		&i.TenantID,
		&i.TenantSlug,
	)
	return i, err
}

const incrementLoginAttempts = `-- name: IncrementLoginAttempts :exec
UPDATE users
SET failed_login_attempts = failed_login_attempts + 1, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IncrementLoginAttempts(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementLoginAttempts, id)
	return err
}

const lockUserAccount = `-- name: LockUserAccount :exec
UPDATE users
SET locked_until = $2, failed_login_attempts = 0, updated_at = NOW()
WHERE id = $1
`

type LockUserAccountParams struct {
	ID          pgtype.UUID
	LockedUntil pgtype.Timestamptz
}

func (q *Queries) LockUserAccount(ctx context.Context, arg LockUserAccountParams) error {
	_, err := q.db.Exec(ctx, lockUserAccount, arg.ID, arg.LockedUntil)
	return err
}

const resetLoginAttempts = `-- name: ResetLoginAttempts :exec
UPDATE users
SET failed_login_attempts = 0, locked_until = NULL, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ResetLoginAttempts(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, resetLoginAttempts, id)
	return err
}

const updateUserMFA = `-- name: UpdateUserMFA :one
UPDATE users
SET mfa_secret = $2, mfa_enabled = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, email, password_hash, full_name, is_email_verified, default_tenant_id, created_at, updated_at, mfa_secret, mfa_enabled, failed_login_attempts, locked_until
`

type UpdateUserMFAParams struct {
	ID         pgtype.UUID
	MfaSecret  pgtype.Text
	MfaEnabled bool
}

func (q *Queries) UpdateUserMFA(ctx context.Context, arg UpdateUserMFAParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserMFA, arg.ID, arg.MfaSecret, arg.MfaEnabled)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsEmailVerified,
		&i.DefaultTenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MfaSecret,
		&i.MfaEnabled,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users
SET password_hash = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, email, password_hash, full_name, is_email_verified, default_tenant_id, created_at, updated_at, mfa_secret, mfa_enabled, failed_login_attempts, locked_until
`

type UpdateUserPasswordParams struct {
	ID           pgtype.UUID
	PasswordHash pgtype.Text
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsEmailVerified,
		&i.DefaultTenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MfaSecret,
		&i.MfaEnabled,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
	)
	return i, err
}

const updateUserProfile = `-- name: UpdateUserProfile :exec
UPDATE users
SET 
    full_name = COALESCE($1, full_name),
    updated_at = NOW()
WHERE id = $2
`

type UpdateUserProfileParams struct {
	FullName pgtype.Text
	ID       pgtype.UUID
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) error {
	_, err := q.db.Exec(ctx, updateUserProfile, arg.FullName, arg.ID)
	return err
}

const verifyUserEmail = `-- name: VerifyUserEmail :one
UPDATE users
SET is_email_verified = TRUE, updated_at = NOW()
WHERE id = $1
RETURNING id, email, password_hash, full_name, is_email_verified, default_tenant_id, created_at, updated_at, mfa_secret, mfa_enabled, failed_login_attempts, locked_until
`

func (q *Queries) VerifyUserEmail(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, verifyUserEmail, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsEmailVerified,
		&i.DefaultTenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MfaSecret,
		&i.MfaEnabled,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
	)
	return i, err
}
